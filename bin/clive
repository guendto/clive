#!/usr/bin/perl
# -*- coding: ascii -*-
#
# Copyright (C) 2010 Toni Gundogdu.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

use warnings;
use strict;

use version 0.77 (); our $VERSION = version->declare("2.3.0_2");

binmode STDOUT, ":utf8";
binmode STDERR, ":utf8";

use Getopt::ArgvFile (
home            => 1,
startupFilename => [qw(.cliverc .clive/config .config/clive/config)],
fileOption      => '--config-file'
);
use Getopt::Long qw(:config bundling);
use Encode qw(decode_utf8);

my %config;
my @queue;
my $video;

exit main ();

sub main {
    init ();
    return process_queue ();
}

sub init {
    GetOptions (\%config,
    'help'    => \&print_help,
    'version' => \&print_version,
    'license' => \&print_license,
    'quiet',
    'format|f=s',
    'output_file|output-file|O=s',
    'no_download|no-download|n',
    # Configuration:
    'quvi=s',
    'get_with|get-with=s',
    'filename_format|filename-format=s',
    'regexp=s',
    'exec=s',
    ) or exit 1;

    $config{format}          ||= 'default';
    $config{filename_format} ||= '%t.%s';
    $config{regexp}          ||= '/(\\w|\\s)/g';

    require Carp;

    # Check --quvi.
    Carp::croak "error: specify path to quvi(1) command with --quvi"
        unless $config{quvi};

    # Check --get-with.
    Carp::croak "error: specify path to a download command with --get-with\n"
        unless $config{get_with};

    # Check --regexp.
    apply_regexp ();

    add_queue ($_)  foreach @ARGV;

    if (scalar @queue == 0)
        { add_queue ($_) while <STDIN>; }

    @queue = uniq2 (@queue); # Remove duplicate URLs.

    select STDOUT; $| = 1; # Go unbuffered.
}

sub add_queue {

    my $ln = trim (shift);
    chomp $ln;

    return if $ln =~ /^$/;
    return if $ln =~ /^#/;

    $ln = "http://$ln"  if $ln !~ m{^http://}i;

    push @queue, $ln;
}

sub uniq2 { # http://is.gd/g8jQU
    my %seen = ();
    my @r = ();
    foreach my $a (@_) {
        unless ($seen{$a}) {
            push @r, $a;
            $seen{$a} = 1;
        }
    }
    return @r;
}

sub process_queue {

    require JSON::XS;

    my $n = scalar @queue;
    my $i = 0;
    my $r = 0;
    my $fpath;

    foreach (@queue) {

        print_checking (++$i, $n);

        my $q = $config{quvi};
           $q =~ s/%u/"$_"/;
           $q .= " -q"  if $q !~ /-q/; # Force --quiet.
           $q .= " -f $config{format}";

        my $o = join '', qx/$q/;

        $r = $? >> 8;

        next unless $r == 0;

        $video = JSON::XS::decode_json ($o);

        print "done.\n"  unless $config{quiet};

        ($r, $fpath) = get_video ();

        if ($r == 0) {
            if ($config{exec})
                { $r = invoke_exec ($fpath); }
        }
    }

    return $r;
}

sub print_checking {

    return  if $config{quiet};

    my ($i, $n) = @_;

    print "($i of $n) "  if $n > 1;
    print "Checking ...";
}

sub get_video {

    require File::Basename;

    my $fpath = get_filename ();
    my $fname = File::Basename::basename ($fpath);

    if ($config{no_download})
        { print_video ($fname); return 0; }

    return write_video ($fpath, $fname);
}

sub invoke_exec {

    my $fpath = shift;

    my $e =  $config{exec};
       $e =~ s/%f/"$fpath"/g;

    qx/$e/;

    return $? >> 8;
}

sub to_mb { return (shift) / (1024*1024); }

sub print_video {
    printf "%s  %.2fM  [%s]\n",
        shift,
        to_mb ($video->{link}[0]->{length_bytes}),
        $video->{link}[0]->{content_type};
}

sub write_video {

    my ($fpath, $fname) = @_;

    my $g = $config{get_with};
       $g =~ s/%u/"$video->{link}[0]->{url}"/g;
       $g =~ s/%f/"$fpath"/g;
       $g =~ s/%n/"$fname"/g;

    qx/$g/;

    return ($? >> 8, $fpath);
}

sub get_filename {

    my $fpath;

    if ($config{output_file})
        { $fpath = $config{output_file}; }
    else
        { $fpath = apply_output_path (apply_filename_format ()); }

    return $fpath;
}

sub apply_output_path {

    require Cwd;

    # Do not touch.
    my $cwd     = decode_utf8 (Cwd::getcwd);
    my $fname   = shift;

    require File::Spec::Functions;

    return File::Spec::Functions::catfile ($cwd, $fname);
}

sub apply_filename_format {

    return $config{output_filename}
        if $config{output_filename};

    my $title = trim (apply_regexp ($video->{page_title}));
    my $fname = $config{filename_format};

    $fname =~ s/%s/$video->{link}[0]->{file_suffix}/g;
    $fname =~ s/%h/$video->{host}/g  if $video->{host}; # quvi 0.2.8+
    $fname =~ s/%i/$video->{id}/g;
    $fname =~ s/%t/$title/g;

    return $fname;
}

sub trim {
    my $s = shift;
    $s =~ s{^[\s]+}//;
    $s =~ s{\s+$}//;
    $s =~ s{\s\s+}/ /g;
    return $s;
}

sub apply_regexp {
    my ($title, $rq) = (shift, qr|^/(.*)/(.*)$|);

    if ($config{regexp} =~ /$rq/) {

        return unless $title; # Must be a syntax check.

        $title = decode_utf8 ($title); # Do not touch.

        my ($pat, $flags, $g, $i) = ($1, $2);

        if ($flags) {
            $g = ($flags =~ /g/);
            $i = ($flags =~ /i/);
        }

        $rq = $i ? qr|$pat|i : qr|$pat|;

        return
            $g
            ? join '', $title =~ /$rq/g
            : join '', $title =~ /$rq/;
    }

    print STDERR
        "invalid syntax (`$config{regexp}'), expected Perl like syntax "
        . "`/pattern/flags', e.g. `/(\\w)/g'";

    exit 1;
}

sub print_help {
    require Pod::Usage;
    Pod::Usage::pod2usage (-exitstatus=>0, -verbose=>1);
}

sub print_version {
    printf "clive $VERSION with Perl %s on %s\n",
        (sprintf "%vd", $^V), $^O;
    exit 0;
}

sub print_license {
print
"# Copyright (C) 2010 Toni Gundogdu.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
";
    exit 0;
}

__END__

=head1 NAME

clive - command line video extraction tool

=head1 SYNOPSIS

clive [E<lt>optionsE<gt>] [E<lt>urlE<gt> ...]

=head1 DESCRIPTION

clive is a command line video extraction tool for Youtube and other similar
video websites that require Adobe Flash for viewing the content.

=head1 OPTIONS

      --help                      print help and exit
      --version                   print version and exit
      --license                   print license and exit
      --quiet                     turn off all output excl. errors
  -f, --format arg (=default)     download video format
  -O, --output-file arg           write downloaded video to file
  -n, --no-download               do not download video, print info only
      --config-file arg           file to read clive arguments from
Configuration:
  --quvi arg                      path to quvi(1) with additional args
  --get-with arg                  path to download command with args
  --filename-format arg (=%t.%s)  output video filename format
  --regexp arg (=/(\w|\s)/g)      regexp to clean up video title
  --exec arg                      invoke arg when download finishes

=head1 OPTIONS - GENERAL

=over 4

=item B<--help>

Print help and exit.

=item B<--version>

Print version and exit.

=item B<--license>

Print license and exit.

=item B<--quiet>

Turn off all I<clive> output excluding errors. Note that this switch has no
effect on any of the third party commands that clive calls.

=item B<-f, --format> I<arg>

Download I<arg> format of the video. Run C<quvi(1)> with C<--support> to get
a list of the supported formats.

=item B<-O, --output-file> I<arg>

Write video to I<arg>.

=item B<-n, --no-download>

Do not download the video, display video details only.

=item B<--config-file> I<arg>

Path to a file to read clive arguments from. By default clive reads
from C<~/.cliverc>, C<~/.clive/config> and C<~/.config/clive/config>.

=back

=head1 OPTIONS - CONFIGURATION

You can specify I<any> of the the command line options in the configuration
file. These options are under C<Configuration> for superficial reasons
(C<--help> output) only.


=over 4

=item B<--quvi> I<arg>

Path to C<quvi(1)> command with any additional arguments. clive calls this
command to parse the video details (e.g. download URL). The following
specifiers are supported:

    %u  Video URL

Note that I<all> occurences of the specifier will be replaced. clive also
appends C<--quiet> to I<arg> if it's not found.

If you use an HTTP proxy with C<quvi(1)>, you should extend that use to
C<--get-with>, especially if your proxy masks your IP. Some websites
refuse to work different IPs requesting the same URL.

=item B<--get-with> I<arg>

Path to a download command (e.g. C<wget(1)> or C<curl(1)>) with any additional
arguments. clive calls this command to download the video. The following
specifiers are supported:

    %u  Video download URL
    %f  Full path to video file
    %n  Video file name

Note that I<all> occurences of the specifier will be replaced. See also the
note about the use of an HTTP proxy above with C<--quvi>.

=item B<--filename-format> I<arg>

Use I<arg> to specify the video output filename format. The default is "%t.%s".
The following specifiers are supported:

    %t  Video title (after applying --regexp)
    %i  Video ID
    %h  Video host ID (req. quvi 0.2.8+)
    %s  Video file suffix (parsed from server returned content-type)

Note that I<all> occurences of the specifier will be replaced.

=item B<--regexp> I<arg>

Use regular expression I<arg> to clean up the video title before
it is used in the output filename. The default is "/(\w|\s)/g".

Note that the syntax supports both "i" (case-insensitive) and "g"
(global or find all).

=item B<--exec> I<arg>

Invoke I<arg> after video download finishes. The following specifiers
are supported:

    %f  Full path to the downloaded video file

Note that I<all> occurences of the specifier will be replaced.

=back

=head1 EXAMPLES

These examples assume you have set C<--quvi> and C<--get-with> in the config
file. See L</FILES>.

=over 4

=item B<clive "http://www.youtube.com/watch?v=DUM1284TqFc">

Typical use.

=item B<clive "http://www.youtube.com/watch?v=DUM1284TqFc" -f sd_270p>

Same but get the sd_270p (Youtube specific) format instead. See
C<--support> for a complete list of websites and formats.

=item B<clive "http://www.youtube.com/watch?v=DUM1284TqFc" -n>

Do not download the video. Print the video details only.

=item B<echo "http://www.youtube.com/watch?v=DUM1284TqFc" | clive>

Yet another way to feed clive with an URL.

You can also feed clive several URLs on one go, either by adding each on
the command line (arg1, arg2, ...) or by redirecting them, for example,
from a file. Each URL must be separated with a newline.

Consider the following example:

  % cat >> urls.lst
  http://www.youtube.com/watch?v=DUM1284TqFc
  http://www.youtube.com/watch?v=TqgTz8ymZl8
  (ctrl+d)
  % clive < urls.lst

=back

=head1 FILES

=over 4

=item B<~/.clive>

=item B<~/.clive/config>

=item B<~/.config/clive/config>

You can also run clive with C<--config-file /path/to/config/file>. Typical
configuration file could look like:

    --quvi "/usr/bin/quvi %u"
    --get-with "/usr/bin/curl -L -C - -o %f %u"
    --filename-format "%t_%i.%s"
    --exec "/usr/bin/vlc %f"

Note the prepending dashes.

=back

=head1 EXIT STATUS

clive exits with 0 on success, otherwise the code is E<gt>0. clive exits with
1 if an error occurred while parsing the command line arguments.

You should note that clive passes whatever any of the other commands it
calls as its exit status. For example, if C<quvi(1)> a non-zero value,
clive exits with it. Refer to the documentation of those commands for the
different exit statuses.

If you are planning to use clive for anything more peculiar, you should
feed clive with only one URL at a time, because clive exits with the
"last exit status". To illustrate this:

    * You feed clive with two URLs
    * First URL fails for some reason, quvi exits with a non-zero value
    * Second URL succeeds, quvi exits with a zero value
    * clive exits with zero

=head1 MANGLED CHARACTERS

Check your terminal settings for an invalid locale setting. You can get
a list of the available locale names by running C<locale -a>. Also, make
sure your terminal supports unicode. e.g.:

    % LANG=en_US.UTF8 urxvt&
    % clive ... # in the new opened terminal

libquvi (which clive ultimately uses) converts the characters to unicode
if the parsed data contains the charset meta tag. Otherwise the characters
are copied from the original content as they are without any conversion.

=head1 CONTRIBUTING

=over 4

=item B<Add support for a website>

This is quvi(1) territory, please visit L<http://quvi.googlecode.com/>.

You can also find the the READMEs and HOWTOs (on most systems) from
$prefix/share/quvi and $prefix/share/doc/quvi directories. Or visit:

    <http://repo.or.cz/w/quvi.git/tree/HEAD:/doc>
    <http://repo.or.cz/w/quvi.git/tree/HEAD:/share/lua>

=item B<Submitting patches>

If you have cooked up a patch, please submit it to the tracker see L</OTHER>.
Pull requests from git repos are also welcome.

=back

=head1 OTHER

<http://clive.googlecode.com/>

<http://sourceforge.net/projects/clive/support>

<git://repo.or.cz/clive.git>

=head1 SEE ALSO

C<quvi(1)>  C<wget(1)>  C<curl(1)>

=head1 AUTHOR

Toni Gundogdu <legatvs at sign gmail com>.

=cut
